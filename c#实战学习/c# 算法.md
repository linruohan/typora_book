# c#算法

[toc]

## 算法目录

分治法

推排序

二叉树

动态规划

贪心算法

图

## 算法的作用

![image-20210630210655473](imgs/image-20210630210655473.png)

## 学习算法的作用

理解编程

让编码过程更通畅

提高解决程序问题的能力

## 分治算法

![image-20210630211231843](imgs/image-20210630211231843.png)

### 最大子数组问题

![image-20210630211944446](imgs/image-20210630211944446.png)

#### 暴力求解

![image-20210630212955010](imgs/image-20210630212955010.png)

![image-20210630213228530](imgs/image-20210630213228530.png)

#### 分治法

![image-20210630213603561](imgs/image-20210630213603561.png)

![image-20210630215621166](imgs/image-20210630215621166.png)

![image-20210630215834197](imgs/image-20210630215834197.png)

![image-20210630220413369](imgs/image-20210630220413369.png)

![image-20210630220531286](imgs/image-20210630220531286.png)

![image-20210630221126603](imgs/image-20210630221126603.png)

![image-20210630221458389](imgs/image-20210630221458389.png)

![image-20210630221723558](imgs/image-20210630221723558.png)

![image-20210630221856530](imgs/image-20210630221856530.png)

![image-20210630222315157](imgs/image-20210630222315157.png)

## 树-数据结构的一种

![image-20210701204031128](imgs/image-20210701204031128.png)

### 树的层次\深度\有序和无序树

![image-20210701204506761](imgs/image-20210701204506761.png)

### 树的错误案例

![image-20210701204546751](imgs/image-20210701204546751.png)

### 树的存储结构

![image-20210701204842593](imgs/image-20210701204842593.png)

1. 顺序存储: 数组,数据间的关系难以记录

2. 链式存储: 定义对象,通过引用互相访问,默认使用链式

#### 链式存储的方式

1. 双亲表示法

   可以很方便的访问到父亲节点,但无法方便的访问到兄弟和子节点

   ![image-20210701205314976](imgs/image-20210701205314976.png)

2. 孩子表示法

   ![image-20210701205456164](imgs/image-20210701205456164.png)

   ![image-20210701205622254](imgs/image-20210701205622254.png)

   可以很方便的访问到孩子节点,不方便访问到父亲节点和兄弟节点

   浪费存储空间且扩展性不大

3. 孩子兄弟表示法

   你的数据  你的第一个孩子  你自己右边的兄弟

   很难得到父亲节点

   ![image-20210701205536819](imgs/image-20210701205536819.png)

   ![image-20210701205901614](imgs/image-20210701205901614.png)

## 二叉树(堆排序)



### 什么是二叉树

每个节点最多只能有两个子节点,且两个子节点间有左右顺序的

![image-20210701210354279](imgs/image-20210701210354279.png)

* 空二叉树:一个节点都没有
* 只有根节点
* 大于一个节点

![](imgs/image-20210701210110947.png)

### 左右子树

B下面的一串是左子树,C是右子树

### 特殊的二叉树

1. 斜树:只有一边
   1. 左斜树:往左斜
   2. 右斜树:往右斜

![image-20210701210915477](imgs/image-20210701210915477.png)

2. 满二叉树

   树的除了最后一层外的其他任意一层都有两个子节点

   ![image-20210701211048190](imgs/image-20210701211048190.png)

3. 完全二叉树:对一颗具有N个节点的二叉树按层序编号,如果编号为i(1<i<n)的节点与周围同样深度的满二叉树中编号为i的节点在二叉树中位置完全相同,则这颗二叉树成为完全二叉树.

   ![image-20210701211329976](imgs/image-20210701211329976.png)

满二叉树最后一层,从右向左,开始依次连续的减少,,不能隔几个少,就形成了完全二叉树

满二叉树==完全二叉树

### 非完全二叉树

![image-20210701211905250](imgs/image-20210701211905250.png)

### 二叉树的性质

1. 在二叉树的第i层上最多右2^i-1^个节点(i>=1)

   ​	![image-20210701212948444](imgs/image-20210701212948444.png)

2. 深度为k的二叉树之多右2^k^-1个节点

   ![](imgs/image-20210701213241079.png)

3. 对于一个完全二叉树,假设有n个节点,堆节点从1开始编号,对任一节点满足下面条件

   1. 他的双亲是节点i/2(除了i=1)
   2. 左孩子是2i,右孩子是2i+1
   3. 如果2i>n说明无左孩子,2i+1>n说明无右孩子

   ![](imgs/image-20210701213424156.png)

### 二叉树的存储结构

#### 顺序存储

一般的树来说是一对多的关系,使用顺序结构存储起来较困难,但是`二叉树`是一种特殊的树,`每个节点最多有二个子节点`,并且`子节点有左右之分`,并且`兄弟/父亲/孩子可以很方便的通过编号获得`,所以我们使用顺序结构进行二叉树的存储

==顺序存储一般用于完全二叉树的存储==

##### 二叉树存储(满二叉树)

按照满二叉树的状态进行编号,根据编号获取数组的索引

![image-20210701213857723](imgs/image-20210701213857723.png)

##### 二叉树存储(部分二叉树)

![image-20210701214143078](imgs/image-20210701214143078.png)

##### 二叉树存储(左右斜二叉树)

![image-20210701214340041](imgs/image-20210701214340041.png)

#### 顺序存储的代码实现

二叉树类

![image-20210701220910865](imgs/image-20210701220910865.png)

存储类

![image-20210701222442319](imgs/image-20210701222442319.png)

![image-20210701222452628](imgs/image-20210701222452628.png)



#### 链式存储:二叉链表存储

二叉树每个节点最多有两个孩子,所以设计一个数据和两个指针域,这样的链表称为二叉链表

![image-20210701214711063](imgs/image-20210701214711063.png)

![image-20210701214726840](imgs/image-20210701214726840.png)

### 二叉树的遍历

二叉树的遍历是从根节点开始,按照某种次序依次访问二叉树中的所有节点,使得每个节点仅且被访问一次

1. 前序遍历:先输出当前节点的数据,在一次遍历输出左节点和右节点

![image-20210701215154979](imgs/image-20210701215154979.png)

![image-20210701215600851](imgs/image-20210701215600851.png)

==前序遍历:非完全二叉树,存储-1表示数据为空==

![image-20210701221854459](imgs/image-20210701221854459.png)

2. 中序遍历: 先遍历输出左节点,在输出当前节点的数据,在遍历输出右节点

   ![image-20210701215815571](imgs/image-20210701215815571.png)



![image-20210701215822802](imgs/image-20210701215822802.png)

中序遍历

![image-20210701222045636](imgs/image-20210701222045636.png)

3. 后序遍历: 先便利输出左节点,在遍历输出右节点,最后输出当前节点的数据

   ![image-20210701220105857](imgs/image-20210701220105857.png)

   ![image-20210701222241304](imgs/image-20210701222241304.png)

4. 层序遍历:从书店第一层开始,从上到下逐层遍历,在同一层中,从左到右对节点逐个访问输出

   ![image-20210701220234516](imgs/image-20210701220234516.png)

![image-20210701222421657](imgs/image-20210701222421657.png)

![image-20210701222533802](imgs/image-20210701222533802.png)

### 二叉排序树
![image-20210701222654418](imgs/image-20210701222654418.png)

![image-20210701222701571](imgs/image-20210701222701571.png)
#### 二叉排序树的删除操作
![image-20210701223100987](imgs/image-20210701223100987.png)
![image-20210701222956693](imgs/image-20210701222956693.png)

#### 二叉排序树的存储
因为二叉排序树的存储,和自身值的大小有关系,不可以使用顺序结构,使用链式结构存储
#### 二叉排序树的代码实现
`树类定义BSTree`	`节点类定义BSNode`

![image-20210703071803818](imgs/image-20210703071803818.png)
![image-20210701224716334](imgs/image-20210701224716334.png)

![image-20210701224618094](imgs/image-20210701224618094.png)

##### 二叉排序树链式存储
![image-20210701232432906](imgs/image-20210701232432906.png)

###### 中序排序
![image-20210701232724670](imgs/image-20210701232724670.png)

![image-20210701232740284](imgs/image-20210701232740284.png)

##### 查找
![image-20210701233102719](imgs/image-20210701233102719.png)

###### ==查找方法的优化==

第一种
![image-20210701233308313](imgs/image-20210701233308313.png)
第二种
![image-20210701233433347](imgs/image-20210701233433347.png)

##### 二叉排序树的删除操作

![image-20210703065944557](imgs/image-20210703065944557.png)

1. 删除节点为叶子节点的情况

![image-20210703070431709](imgs/image-20210703070431709.png)

![image-20210703070259428](imgs/image-20210703070259428.png)

2. 删除节点是仅有左子树或右子树的情况

![image-20210703070507733](imgs/image-20210703070507733.png)

![image-20210703070724277](imgs/image-20210703070724277.png)

3. 既有左节点又有右节点

   ![image-20210703071423040](imgs/image-20210703071423040.png)

![image-20210703071338017](imgs/image-20210703071338017.png)

==代码测试==

![image-20210703071705771](imgs/image-20210703071705771.png)

![image-20210703071648200](imgs/image-20210703071648200.png)

## 堆

### 堆定义

堆是具有下列性质的完全二叉树: 每个节点的值都>=其左右孩子节点的值,称为大顶堆;或者每个节点的值都<=其左右孩子节点的值,称为小顶堆;

![image-20210703072102576](imgs/image-20210703072102576.png)

### 堆排序

是利用堆(大顶堆和小顶堆)进行排序的方法

将待排序的序列构造成一个大顶堆,此时整个系列的最大值就是根节点,将它一走(根堆的最后一个元素进行交换,此时末尾元素就是最大值),然后将剩余的n-1个序列重新构造成一个堆,这样会得到n个元素中的次小值,如此反复执行,就能得到一个有序序列了

![](imgs/image-20210703072512968.png)

### 使用代码将二叉树构造出大顶堆

![image-20210703074429027](imgs/image-20210703074429027.png)

![image-20210703074210823](imgs/image-20210703074210823.png)

![image-20210703075307110](imgs/image-20210703075307110.png)

![image-20210703075109645](imgs/image-20210703075109645.png)

![image-20210703075336799](imgs/image-20210703075336799.png)



#### 抽调公共函数

![image-20210703075516374](imgs/image-20210703075516374.png)

![image-20210703075600262](imgs/image-20210703075600262.png)

### 动态规划算法(Dynamic Programming)

![image-20210703121546815](imgs/image-20210703121546815.png)

#### 钢条切割问题

![image-20210703121836780](imgs/image-20210703121836780.png)

![image-20210703122315127](imgs/image-20210703122315127.png)

第一种: 递归调用: 一共切为n段,计算每一段的最优解

![image-20210703122701781](imgs/image-20210703122701781.png)

第二种: 先切一部分,计算他的收益,再对剩下的切一部分,计算剩下部分的最优解,依次循环

自顶向下递归实现

![image-20210703124631073](imgs/image-20210703124631073.png)

#### 背包问题

![image-20210703131014031](imgs/image-20210703131014031.png)

### 贪心算法

![image-20210703161147784](imgs/image-20210703161147784.png)

![image-20210703161221716](imgs/image-20210703161221716.png)

#### 活动选择问题

![image-20210703161418776](imgs/image-20210703161418776.png)

![image-20210703162359130](imgs/image-20210703162359130.png)

![image-20210703170011280](imgs/image-20210703170011280.png)

#### 钱币找零问题

![image-20210703172520704](imgs/image-20210703172520704.png)

#### 图

<<大话数据结构.pdf>> ==TODU==

![image-20210703175246381](imgs/image-20210703175246381.png)

![image-20210703175259056](imgs/image-20210703175259056.png)

![image-20210703175311341](imgs/image-20210703175311341.png)

![image-20210703175440927](imgs/image-20210703175440927.png)

![image-20210703175519867](imgs/image-20210703175519867.png)

![image-20210703175602576](imgs/image-20210703175602576.png)

![image-20210703175749298](imgs/image-20210703175749298.png)

![image-20210703175806254](imgs/image-20210703175806254.png)

![image-20210703175815495](imgs/image-20210703175815495.png)

![image-20210703175825464](imgs/image-20210703175825464.png)

![image-20210703175831029](imgs/image-20210703175831029.png)
