# 虚拟地址、逻辑地址、线性地址、物理地址

[toc]

- 虚拟地址
   指由程序产生的由`段选择符`和`段内偏移地址`组成的地址。
- 逻辑地址
   指由程序产生的段内偏移。有时候直接把逻辑地址当做虚拟地址。
- 线性地址
   指虚拟地址到物理地址变换的中间层，是处理器可寻址的内存空间中的地址。程序代码会产生逻辑地址，也就是段中的偏移地址，加上相应的段基址就成了线性地址。如果开启了分页机制，那么线性地址需要再经过变换，转为为物理地址。如果无分页机制，那么线性地址就是物理地址。
- 物理地址
   指CPU外部地址总线上寻址物理内存的地址信号，是地址变换的最终结果。

虚拟地址到物理地址的转化是体系结构相关的，一般由分段和分页两种方式。以X86CPU为例，分段和分页都是支持的。内存管理单元负责从虚拟地址到物理地址的转化。逻辑地址是段标识+段内偏移的形式。MMU通过查询段表，可以将逻辑地址转化为线性地址。无分页机制时，线性地址就是物理地址，有分页时，MMU还需要查询页表来将线性地址转化为物理地址：逻辑地址（段表）->线性地址（页表）->物理地址。

映射是一种多对一的关系，即不同的逻辑地址可以映射到同一个线性地址上；不同的线性地址也可以映射到同一个物理地址上。而且，同一个线性地址在换页之后，可能被装载到另一个物理地址上，所以这种多对一的映射关系会随时间发生变化。



作者：saviochen
链接：https://www.jianshu.com/p/8b37d10bc504
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 两个内存概念

`物理内存`：人尽皆知，就是插在主板上的 内存条 。他是固定的，内存条的容量多大，物理内存就有多大（集成显卡系统除外）。但是如果程序运行很多或者程序本身很大的话，就会导致大量的物理内存占用，甚至导致物理内存消耗殆尽。
虚拟内存：简明的说，虚拟内存就是在硬盘上划分一块 页面文件，充当内存 。当程序在运行时，有一部分资源还没有用上或者同时打开几个程序却只操作其中一个程序时，系统没必要将程序所有的资源都塞在物理内存中，于是，系统将这些暂时不用的资源放在虚拟内存上，等到需要时在调出来用。

## 三个地址概念

1. 物理地址(physical address)：用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。
   ——这个概念应该是这几个概念中最好理解的一个，但是值得一提的是，虽然可以直接把物理地址理解成插在机器上那根内存本身，把内存看成一个从0字节一直到 最大空量逐字节的编号的大数组，然后把这个数组叫做物理地址，但是事实上，这只是一个硬件提供给软件的抽像，内存的寻址方式并不是这样。所以，说它是“与 地址总线相对应”，是更贴切一些，不过抛开对物理内存寻址方式的考虑，直接把物理地址与物理的内存一一对应，也是可以接受的。也许错误的理解更利于形而上的抽像。

2. 逻辑地址(logical address)\****：是指由程序产生的与段相关的偏移地址部分。例如，你在进行C语言指针 [编程](http://www.2cto.com/kf) 中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址，不和绝对物理地址相干。
   **

3. 线性地址(linear address)或也叫虚拟地址(virtual address)**
   跟逻辑地址类似，它也是一个不真实的地址，如果逻辑地址是对应的硬件平台 段 式管理转换前地址 的话，那么线性地址则对应了硬件 页式内存的转换前地址 。

   ---

   每个进程都有4GB的虚拟地址空间
   这4GB分3部分 
   （1）一部分映射物理内存
   （2）一部分映射硬盘上的交换文件
   （3）一部分什么也不做

程序中都是使用4GB的虚拟地址，访问物理内存需要使用物理地址，物理地址是放在寻址总线上的地址，以字节（8位）为单位。

## 虚拟内存

  我们`编程时所面对的都是虚拟地址`,对于每个进程来说都拥有4G的虚拟内存(小补充: 4G虚拟内存中,高2G内存属于内核部分,是所有进程共有的,低2G内存数据是进程独有的,每个进程低2G内存都不一样),但注意的是虚拟地址是操作系统自己意淫出来的,打个比方就是说想法还未付诸实践,所以不构成任何资源损失.比如我们要在0x80000000的地方写个"UESTC"的时候,操作系统就会将这个虚拟地址映射到一块物理地址A中,你写这块虚拟地址就相当于写物理地址A.但是加入我们只申请了一段1KB的虚拟内存空间,并未读写,系统是不会分配任何物理内存的,只有当虚拟内存要使用时系统才会分配相应的物理空间.

## 物理内存

  接下来就到物理内存的东东了,其实呢 物理内存的管理是基于一个数组来管理的,听说过分页机制吧,下面说下分页.windows下分页是4kb一页 那么假设我们物理内存有4GB 那么windows会将这4GB空间分页,分成4GB/4KB = 1M页  那么每一页(就是4KB)的物理空间都由一个叫PHYSICAL_PAGE的数据结构管理,这个数据结构就不写啦....一来我写的手酸 二来看的人也累~~说说思路就好了.

### 物理地址和逻辑地址

1. **物理地址**：`加载到内存地址寄存器中的地址，`内存单元的真正地址。在前端总线上传输的内存地址都是物理内存地址，编号从0开始一直到可用物理内存的最高端。这些数字被北桥(Nortbridge chip)映射到实际的内存条上。物理地址是明确的、最终用在总线上的编号，不必转换，不必分页，也没有特权级检查(no translation, no paging, no privilege checks)。

2. **逻辑地址**：CPU所生成的地址。逻辑地址是内部和编程使用的、并不唯一。例如，你在进行C语言指针编程中，可以读取指针变量本身值(&操作)，实际上这个值就是逻辑地址，它是相对于你当前进程数据段的地址（偏移地址），不和绝对物理地址相干。

为什么会有这两种地址？

个人觉的原因在于逻辑地址分配更加灵活，可以允许不唯一，看起来也较为直观，例如，一段代码中分配数组，逻辑地址上是连续的，然而在物理地址上，这个数组所占用的页可能分散开来，物理地址上就是不连续的，这样对程序的可理解性上有影响。另外，有了逻辑地址这个概念，才能使用虚拟内存技术。

### Paging分页内存管理方案

(1) 分页的最大作用就在于：使得进`程的物理地址空间可以是非连续`的。

物理内存被划分为一小块一小块，每块被称为帧(Frame)。分配内存时，帧是分配时的最小单位，最少也要给一帧。在逻辑内存中，与帧对应的概念就是页(Page)。

```python
逻辑地址的表示方式是：页码+页偏移
```

例如，已知逻辑空间地址为2^m个字节（也就是说逻辑地址的长度是m位），已知页大小是2^n字节。那么一共可以有2^(m-n)个页。因此页码部分会占m-n位，之后的n位，用来存储页偏移。

举个例子， 页大小为4B，而逻辑内存为32B（8页），逻辑地址0的页号为0，页号0对应帧5，因此逻辑地址映射为物理地址5*4+0=20。逻辑地址3映射物理地址5*4+3=23。逻辑地址13(4*3+1，页号为3，偏移为1，因此帧号为2)，映射到物理地址9。

![img](http://images.cnitblog.com/blog/48332/201311/12230204-439af747b09c4d9b9fc18cf69f531141.png)

采用分页技术不会产生外部碎片(内存都被划分为帧)，但可能产生内部碎片(帧已经是最小单元，因此帧内部可能有空间没有用到)。

按概率计算下来，每个进程平均可有半个帧大小的内部碎片。

(2) 页表的硬件实现

上一小节中写到页表是逻辑地址转化到物理地址的关键所在。那么页表如何存储？

每个操作系统都有自己的方法来保存页表。绝大多数都会为每个进程分配一个页表。现在由于页表都比较大，所以放在内存中(以往是放在一组专用寄存器里)，其指针存在进程控制块(PCB)里，当进程被调度程序选中投入运行时，系统将其页表指针从进程控制块中取出并送入用户寄存器中。随后可以根据此首地址访问页表。

页表的存储方式是**TBL(Translation look-aside buffer, 翻译后备缓冲器)**+内存。TBL实际上是一组硬件缓冲所关联的快速内存。若没有TBL，操作系统需要两次内存访问来完成逻辑地址到物理地址的转换，访问页表算一次，在页表中查找算一次。TBL中存储页表中的一小部分条目，条目以键值对方式存储。

![img](http://images.cnitblog.com/blog/48332/201311/13090353-a81e30238dea4811b9b5382d3eeb0427.png)

(3) 页表的数据结构

a.今年是2013年，现有的笔记本电脑，内存地址空间一般为2^32字节以上。对于具有32位逻辑地址空间的计算机系统，如果系统的页大小为4KB(2^12B)，那么页表可以拥有2^(32-12)个，也就是一百多万个条目，假设每个条目占有4B，那每个进程都需要4MB的物理地址空间来存放页表本身。而且，页表本身需要分配在连续内存中。

为此，***\*Hierarchical Paging(层次化分页)\****被提出，实际上就是将页号分为两部分，第一部分作为索引，第二部分作为页号的偏移。

以一个4kb页大小的32位系统为例。一个逻辑地址被分为20位的页码和12位的页偏移。因为要对页表进行再分页，所以该页号可分为10位的页码和10位的页偏移。这样一个逻辑地址就表示如下形式：

![img](http://images.cnitblog.com/blog/48332/201311/13090739-306c82d13f914d7197a114eeae246ab5.png)

地址转换过程如下：

![img](http://images.cnitblog.com/blog/48332/201311/13091011-3f2922b4ed65405b8ccc65b9737fa014.png)

地址由外向内转换，因此此方法也被称为***\*forward-mapped page table(向前映射表)\****。

b. Hashed Page Tables 哈希页表

处理超过32位地址空间的常用方法是使用***\*hashed page table(哈希页表)\****，并以虚拟页码作为哈希值。哈希页表的每一条目都包括一个链表的元素，这些元素哈希成同一位置。每个元素有三个域：虚拟页码，所映射的帧号，指向链表中下一个元素的指针。

个人看来，哈希页表的地址转换方式，实际上是***\*Chaining(链接)\****方式，也就是一种哈希函数的溢出处理方式(另一种溢出处理方式叫做Open Addressing，开放寻址)，具体过程如下：

逻辑地址需要大于32bit的地址空间来表示，但是操作系统仍只有32bit来表示地址。此时人们便想到虚拟页地址，虚拟地址可以在32bit表示范围之内，然后利用哈希函数完成逻辑地址到虚拟地址的映射，由于虚拟地址更少，哈希函数会出现溢出，这里使用Chaining来解决溢出。

逻辑地址中的页号(下图中的p)经过哈希函数的计算，算出虚拟地址中的页号，根据虚拟页号可以在哈希表中以O(1)方式寻址，用p与链表中的每一个元素的第一个域相比较。如果匹配，那么相应的帧号就用来形成物理地址。如果不匹配，就对链表中的下一个节点进行比较，以寻找一个匹配的页号。

![img](http://images.cnitblog.com/blog/48332/201311/13104212-e3957ec532234cbab06e42ac4d1b5311.png)

c. Inverted page table 反向页表

时间关系，这段暂时略过。

***\*3. Segmentation，分段内存管理方案\****

采用分页内存管理有一个不可避免的问题：用户视角的内存和实际内存的分离。设想一段main函数代码，里面包含Sqrt函数的调用。按照编写者的理解，这段代码运行时，操作系统应该分配内存给：符号表(编译时使用)，栈(存放局部变量与函数参数值)，Sqrt代码段，主函数代码段等。这样，编写者就可以方便地指出："函数sqrt内存模块的第五条指令"，来定位一个元素。而实际上，由于采用Paging的管理方式，所有的一切都只是散落在物理内存中的各个帧上，并不是以编写者的理解来划分模块。

![img](http://images.cnitblog.com/blog/48332/201311/13105648-d82857a6bb2a46e38469058978e92f8b.png)

Segmentation的内存管理方式可以支持这种思路。逻辑地址空间由一组段组成。每个段都有名字和长度。地址指定了段名称和段内偏移。因此用户通过两个量来指定地址：段名称和偏移。段是编号的，通过段号而非段名称来引用。因此逻辑地址由有序对构成：

 <segment-number,offset>(<段号s, 段内偏移d>)

段偏移d因该在0和段界限之间，如果合法，那么就与基地址相加而得到所需字节在物理内存中的地址。因此段表是一组基地址和界限寄存器对。

 

![img](http://images.cnitblog.com/blog/48332/201311/13112137-0cac9e80dbfc4bc7b9e8aa9ae664087c.png)

例如下图，有5个段，编号0~4，例如段2为400B开始于位置4300，对段2第53字节的引用映射成位置4300+53=4353。而段0字节1222的引用则会触发地址错误，因为该段的仅为1000B长(界限为1000)。

![img](http://images.cnitblog.com/blog/48332/201311/13112441-167f767f7e1546a5ab123abbd4fad1e2.png)

***\*4. 合并分段和分页的管理方案\****

在现有的Intel兼容计算机(x86)上，采用的内存管理方案是分段和分页合并的管理方案。

在这个方案中，逻辑地址，如前一节中所说，是由一个段标识符加上一个指定段内相对地址的偏移量，表示为 [段标识符：段内偏移量]。

这样的逻辑地址转换的过程是怎样呢？如下图所示：

![img](http://images.cnitblog.com/blog/48332/201311/15110509-3e98d0a333644e01952e7675ee2dbb71.png)

当*CPU*要执行一条引用了内存地址的指令时，转换过程就开始了。第一步是把逻辑地址转换成**线性地址**。但是，为什么不跳过这一步，而让软件直接使用线性地址（或物理地址呢？）原因主要是因为：

(1) Intel的更新是渐进式而非革命式，新的处理器需要兼容和保留过往的设置。具体的原因，博文Memory Translation and Segmentation (http://blog.csdn.net/drshenlei/article/details/4261909) 中讲的较为清楚。

(2) 如上节所说，采用段内存管理，可以跟方便地进行地址保护(同一类型的地址逻辑地址在一起)。

下面讲逻辑地址到线性地址的部分。

在IBM OS/2 32位版本的操作系统，和Intel 386的环境下。操作系统采用的内存分配方式就是分段和分页合并的方式。

逻辑地址的实际上是一对<选择符，偏移>。

选择符的内容如下：

![img](http://images.cnitblog.com/blog/48332/201311/15225957-67836817299c459db5405bbc75f15be0.jpg)

从左开始，13位是索引(或者称为段号)，通过这个索引，可以定位到**段描述符(segment descriptor)**，而段描述符是可以真正记载了有关一个段的位置和大小信息， 以及访问控制的状态信息。段描述符一般由8个字节组成。由于8B较大，而Intel为了保持向后兼容，将段寄存器仍然规定为16-bit(尽管每个段寄存器事实上有一个64-bit长的不可见部分，但对于程序员来说，段寄存器就是16-bit的)，那么很明显，我们无法通过16-bit长度的段寄存器来直接引用64-bit的段描述符。因此在逻辑地址中，只用13bit记录其索引。而真正的段描述符，被放于数组之中。

这个内存中的数组就叫做**GDT(Global \**Descriptor\** Table，全局描述表)**，Intel的设计者门提供了一个寄存器GDTR用来存放GDT的入口地址。程序员将GDT设定在内存中某个位置之后，可以通过LGDT指令将GDT的入口地址装入此寄存器，从此以后，CPU就根据此寄存器中的内容作为GDT的入口来访问GDT了。

除了GDT之外，还有**LDT(Local Descriptor** **Table，本地描述表)**，但与GDT不同的是，LDT在系统中可以存在多个，每个进程可以拥有自己的LDT。LDT的内存地址在LDTR寄存器中。

在之前图中的TI位，就是用来表示此索引所指向的段描述符是存于全局描述表中，还是本地描述表中。=0，表示用GDT，=1表示用LDT。

RPL位，占2bit，是保护信息位，还没有仔细了解过这一块，暂时先不写。

找到，段描述符后，加上偏移量，便是线性地址。转换过程如下：

![img](http://images.cnitblog.com/blog/48332/201311/15232144-4db8ba86c9564fcab7bab1c90bd9bf10.jpg)

在Intel 386的环境下，线性地址转换为物理地址的过程，和第二节分页式内存管理中，层次分页中，逻辑地址转换为物理地址的方法类似。如下图。

![img](http://images.cnitblog.com/blog/48332/201311/15232858-b7f7f3c854a84da2b409e1a6bbe2211d.jpg)

 

Intel 80386的地址转换全过程如下图：

![img](http://images.cnitblog.com/blog/48332/201311/15224432-4c36b374c6db48898a6922b98c577313.png)