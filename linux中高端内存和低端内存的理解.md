# linux中高端内存和低端内存的理解

## linux内存管理

`用户态的寻址范围是0-3G`，`内核态的寻址范围3-4G`，当时这是`基于32位操作系统`而言的，目前大部分芯片都支持64位了。

用户态和内核态不同的虚拟地址，可能映射的是同一块物理地址。

`高端内存`是Linux中一个重要的概念，初涉Linux时曾经对这个概念非常迷惑。实际上这个概念比较简单，理解这个概念，需要追溯一下Linux的内存管理。

### CPU地址总线（32位）

  从前，`CPU的地址总线只有32位`。32的地址总线无论是从`逻辑`上还是从`物理`上都只能描述`4G的地址空间`，在物理上理论上最多拥有 4G内存（除了IO地址空间，实际内存容量小于4G），逻辑空间也只能描述4G的线性地址空间。

为了合理的利用4G空间，Linux采用了3：1的策略，即`内核占用1G的线性地址空间`，`用户占用3G的线性地址空间`。所以用户进程的地址范围从`0~3G`，内核地址范围从`3G~4G`，也就是说，内核空间只能管理 1G的内存。

对于如此紧张的线性地址资源，内核空间与用户空间的肆意瓜分，导致了内存管理上的问题：`**当物理内存大于1G时，内核线性地址空间小于实际的物理内存容量，内核如何实现对大于1G内存的管理呢？**`

### 内核空间对内存的管理方法

需要提一下内核空间对内存的管理方法。

1. 一方面为了提高内核空间对内存的管理效率；

2. 另一方面，为了简化内核空间对内存的管理方法，内核采用线性映射的方法实现对内存的管理，从Linux实现的方法来看，`物理地址与内核的虚拟地址只差一个偏移量`。所以，当物理内存大于1G时，物理内存无法全部映射到内核线性地址空间，这就产生了上述问题。

#### 高端内存：地址空间大于1G的内存区域

  高端内存的管理需要进行非线性映射，为此，在内核线性地址空间预留了128M的空间，位于线性地址空间的高端。

#### 低端内存：小于1G的内存区域

如今，CPU的地址总线都扩大到64位了，线性地址资源非常丰富，所以，可以给内核空间预留足够的线性地址资源，在最近一段时间内，内核线性地址资源与物理内存容量之间的矛盾将不再突出，高端内存的概念也就在64位CPU上消失了。

1. 永久性映射：Linux将3GB开始的内核虚拟地址空间的896M地址直接映射到物理地址空间的0-896M，这部分是永久性映

射，

2. 剩下的128M则可根据需要进行动态映射，也称临时性映射。

> 只有在物理内存大小超过了内核虚拟地址空间的时候，才会存在高端内存，否则内核虚拟地址空间的大小已经使其足够访问所有的物理内存了。

## linux内存分配区域

### 32位操作系统，内存分区：

**ZONE_DMA**    内存开始的16MB

**ZONE_NORMAL**    16MB~896MB

**ZONE_HIGHMEM**    896MB ~ 结束

Linux系统通常将主内存划分为三个区域。`大多数内存分配到ZONE_NORMAL区域` 。 

1. 在低端，有16MB的内存被分区到DMA区域ZONE_DMA中，该内存被保留用于特定需要的情况。DMA内存最常见的用户是`较旧的外设`，它只能寻址`24位内存`[2^24=16M]。

2. 在高端，ZONE_HIGHMEM包含内核无法直接寻址的所有内存。

并非所有系统都实现所有这些区域。一些较新的体系结构不支持古老的外围设备，而忽略了区域 ZONE_DMA。
一般来说，64位系统没有寻址问题，也不需要ZONE_HIGHMEM。
IA64体系结构决定了ZONE_DMA的另一种实现方式，将其定义为覆盖4GB以下的所有内存。

事实证明，4GB区域有很多用途。相当多的设备在访问不能用32位寻址的内存时遇到问题。这些设备的驱动程序已经被强制使用ZONE_DMA、I/O存储器管理单元（在有ZONE_DMA的系统上）或缓冲区。这些解决方案都不是理想的：ZONE_DMA是一个小而稀缺的资源，IOMMU空间也可能稀缺，反弹缓冲区也很慢。如果在4GB边界下可靠地分配DMA内存，所有这些问题都可以避免。

### 在64位Linux操作系统上(无高端内存)，分区如下：

最开始的16M内存是DMA ZONE 内存，用slab分配器的kmalloc分配获取。
DMA32 ZONE为16M~4G，高于4G的内存为Normal ZONE。

**ZONE_DMA**    内存开始的16MB

**ZONE_DMA32**     16MB~4GB

**ZONE_NORMAL**   4GB ~ 结束

### 内核是如何借助128MB高端内存地址空间访问所有物理内存？

当内核想访问高于896MB物理地址内存时，从0xF8000000 ~ 0xFFFFFFFF地址空间范围内`找一段相应大小空闲`的逻辑地址空间，**借用一会**。借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核PTE页面表），`**临时用一会，用完后归还**`。这样别人也可以借用这段地址空间访问其他物理内存，实现了使用有限的地址空间，访问所有所有物理内存。如下图。



我们可以知道**高端内存的最基本思想**：借一段地址空间，建立临时地址映射，用完后释放，达到这段地址空间可以循环使用，访问所有物理内存。

看到这里，不禁有人会问：万一有内核进程或模块一直占用某段逻辑地址空间不释放，怎么办？若真的出现的这种情况，则内核的高端内存地址空间越来越紧张，若都被占用不释放，则没有建立映射到物理内存都无法访问了。

*对于高端内存，可以通过 alloc_page() 或者其它函数获得对应的 page，但是要想访问实际物理内存，还得把 page 转为线性地址才行（为什么？想想 MMU 是如何访问物理内存的），也就是说，我们需要为高端内存对应的 page 找一个线性空间，这个过程称为高端内存映射。*

对应高端内存的3部分，高端内存映射有三种方式：
**映射到”内核动态映射空间”（noncontiguous memory allocation）**
这种方式很简单，因为通过 vmalloc() ，在”内核动态映射空间”申请内存的时候，就可能从高端内存获得页面（参看 vmalloc 的实现），因此说高端内存有可能映射到”内核动态映射空间”中。

**持久内核映射（permanent kernel mapping）**
如果是通过 alloc_page() 获得了高端内存对应的 page，如何给它找个线性空间？
内核专门为此留出一块线性空间，从 PKMAP_BASE 到 FIXADDR_START ，用于映射高端内存。在 2.6内核上，这个地址范围是 4G-8M 到 4G-4M 之间。这个空间起叫”内核永久映射空间”或者”永久内核映射空间”。这个空间和其它空间使用同样的页目录表，对于内核来说，就是 swapper_pg_dir，对普通进程来说，通过 CR3 寄存器指向。通常情况下，这个空间是 4M 大小，因此仅仅需要一个页表即可，内核通过来 pkmap_page_table 寻找这个页表。通过 kmap()，可以把一个 page 映射到这个空间来。由于这个空间是 4M 大小，最多能同时映射 1024 个 page。因此，对于不使用的的 page，及应该时从这个空间释放掉（也就是解除映射关系），通过 kunmap() ，可以把一个 page 对应的线性地址从这个空间释放出来。

**临时映射（temporary kernel mapping）**
内核在 FIXADDR_START 到 FIXADDR_TOP 之间保留了一些线性空间用于特殊需求。这个空间称为”固定映射空间”在这个空间中，有一部分用于高端内存的临时映射。

这块空间具有如下特点：

（1）每个 CPU 占用一块空间

（2）在每个 CPU 占用的那块空间中，又分为多个小空间，每个小空间大小是 1 个 page，每个小空间用于一个目的，这些目的定义在 kmap_types.h 中的 km_type 中。

当要进行一次临时映射的时候，需要指定映射的目的，根据映射目的，可以找到对应的小空间，然后把这个空间的地址作为映射地址。这意味着一次临时映射会导致以前的映射被覆盖。通过 kmap_atomic() 可实现临时映射。

# [linux内核内存管理(zone_dma zone_normal zone_highmem)](https://www.cnblogs.com/wuchanming/p/4756911.html)

 Linux 操作系统和驱动程序运行在内核空间，应用程序运行在用户空间，两者不能简单地使用指针传递数据，因为Linux使用的虚拟内存机制，用户空间的数据可能被换出，当内核空间使用用户空间指针时，对应的数据可能不在内存中。

 

## Linux内核地址空间划分

通常**32位Linux内核**地址空间划分`0~3G为用户空间`，`3~4G为内核空间`。注意这里是32位内核地址空间划分，64位内核地址空间划分是不同的。

### x86的物理地址空间布局：

 [![wKiom1Nm_tiyhQPXAACWQfYUvVU353.jpg](http://s3.51cto.com/wyfs02/M01/25/CF/wKiom1Nm_tiyhQPXAACWQfYUvVU353.jpg)](http://s3.51cto.com/wyfs02/M01/25/CF/wKiom1Nm_tiyhQPXAACWQfYUvVU353.jpg)

 

　　物理地址空间的顶部以下一段空间，被PCI设备的I/O内存映射占据，它们的大小和布局由PCI规范所决定。640K~1M这段地址空间被BIOS和VGA适配器所占据。

　　Linux系统在初始化时，会根据实际的物理内存的大小，为每个物理页面创建一个page对象，所有的page对象构成一个mem_map数组。

进一步，针对不同的用途，Linux内核将所有的物理页面划分到3类内存管理区中，如图，分别为ZONE_DMA，ZONE_NORMAL，ZONE_HIGHMEM。

　　ZONE_DMA的范围是0~16M，该区域的物理页面专门供I/O设备的DMA使用。之所以需要单独管理DMA的物理页面，是因为DMA使用物理地址访问内存，不经过MMU，并且需要连续的缓冲区，所以为了能够提供物理上连续的缓冲区，必须从物理地址空间专门划分一段区域用于DMA。

　　ZONE_NORMAL的范围是16M~896M，该区域的物理页面是内核能够直接使用的。

　　ZONE_HIGHMEM的范围是896M~结束，该区域即为高端内存，内核不能直接使用。

 

### linux虚拟地址内核空间分布

[<img src="http://s3.51cto.com/wyfs02/M02/25/CF/wKiom1Nm_tezL0_TAACljE7bXGU278.jpg" alt="wKiom1Nm_tezL0_TAACljE7bXGU278.jpg" style="zoom:150%;" />](http://s3.51cto.com/wyfs02/M02/25/CF/wKiom1Nm_tezL0_TAACljE7bXGU278.jpg)

　　在kernel image下面有16M的内核空间用于DMA操作。位于内核空间高端的128M地址主要由3部分组成，分别为vmalloc area，持久化内核映射区，临时内核映射区。

　　由于ZONE_NORMAL和内核线性空间存在直接映射关系，所以内核会将频繁使用的数据如kernel代码、GDT、IDT、PGD、mem_map数组等放在ZONE_NORMAL里。而将用户数据、页表(PT)等不常用数据放在ZONE_ HIGHMEM里，只在要访问这些数据时才建立映射关系(kmap())。比如，当内核要访问I/O设备存储空间时，就使用ioremap()将位于物理地址高端的mmio区内存映射到内核空间的vmalloc area中，在使用完之后便断开映射关系。

 

### linux虚拟地址用户空间分布

**[<img src="http://s3.51cto.com/wyfs02/M00/25/CF/wKiom1NnADvC07kmAACCVbbosf0493.jpg" alt="wKiom1NnADvC07kmAACCVbbosf0493.jpg" style="zoom:150%;" />**

![img](https://pic1.zhimg.com/80/v2-c69bb04076d4f434d9ba3a8110a072fa_1440w.jpg?source=1940ef5c)

**[    所以堆与栈的区别很明显：

    栈内存存储的是局部变量而堆内存存储的是实体；
    栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；
    栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。
------------------------------------------------
用户进程的代码区一般从虚拟地址空间的0x08048000开始，这是为了`便于检查空指针`。代码区之上便是数据区，未初始化数据区，堆区，栈区，以及参数、全局环境变量。

一个程序在内存上由BSS段、data段、text段三个组成的。在没有调入内存前，可执行程序分为代码段、数据区和未初始化数据区三部分。

BSS段：（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量的一块内存区域，属于静态内存分配。BSS段的内容并不存放在磁盘上的程序文件中。原因是内核在程序开始运行前将它们设置为0，**需要存放在程序文件中的只有正文段和初始化数据段**。text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。

数据段：（data segment）通常是指用来存放程序中已初始化的全局变量的一块内存区域，属于静态内存分配。总结为：初始化的全局变量和静态变量在已初始化区域，未初始化的全局变量和静态变量在BSS区。

代码段：（code segment/text segment）通常是指用来存放程序执行代码的一块内存区域。该区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

堆（heap）：用于动态分配内存，位于BSS和栈中间的地址区域，由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，会产生碎片。（**经常问如何解决内存碎片？**）当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间，因此堆的效率比栈要低的多。注：与数据结构中的堆不是一个概念，但堆的分配方式类似于链表。

栈(stack)： 由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中，这个被调用的函数再为它的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出。

实例程序：

![img](https://pic3.zhimg.com/80/v2-76a9eabd5b65e8ba8e363f32d6adafe6_1440w.jpg?source=1940ef5c)

**2.区别：**

1）**管理方式***：*栈由编译器自动管理，无需人为控制。而堆释放工作由程序员控制，容易产生内存泄漏（memory leak）。

2）**空间大小***：*在32位系统下，堆内存可以达到4G的空间（虚拟内存的大小，有面试官问过），从这个角度来看堆内存大小可以很大。但对于栈来说，一般都是有一定的空间大小的（在VC6默认的栈空间大小是1M，也有默认2M的）。可以重新设置，如图：

![img](https://pic1.zhimg.com/80/v2-ceaafa415db46b0a60ae5a0edf35634d_1440w.jpg?source=1940ef5c)

3）**碎片问题***：*堆频繁new/delete会造成内存空间的不连续，造成大量的碎片，使程序效率降低（**重点是如何解决？**如内存池、伙伴系统等）。对栈来说不会存在这个问题，因为栈是先进后出，不可能有一个内存块从栈中间弹出。在该块弹出之前，在它上面的（后进的栈内容）已经被弹出。

4）**生长方向***：*堆生长（扩展）方向是向上的，也就是向着内存地址增加的方向；栈生长（扩展）方向是向下的，是向着内存地址减小的方向增长， 可以看第一张图。

5）**分配方式***：*堆都是动态分配的，没有静态分配的堆。而栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，如局部变量分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。

6）**效率***：*栈是机器系统提供的数据结构，计算机会在底层对栈提供支持（有专门的寄存器存放栈的地址，压栈出栈都有专门的机器指令执行），这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的（可以了解侯捷老师的内存管理的视频，关于malloc/realloc/free函数等）。例如分配一块内存，堆会按照一定的算法，在堆内存中搜索可用的足够大小的空间，如果没有（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。总之，堆的效率比栈要低得多。

**4、linux虚拟地址与物理地址映射的关系**

 [<img src="http://s3.51cto.com/wyfs02/M02/25/D0/wKioL1Nm_qiCvmYxAADRFZV_1jQ205.jpg" alt="wKioL1Nm_qiCvmYxAADRFZV_1jQ205.jpg" style="zoom:150%;" />](http://s3.51cto.com/wyfs02/M02/25/D0/wKioL1Nm_qiCvmYxAADRFZV_1jQ205.jpg)

 　　Linux将4G的线性地址空间分为2部分，0~3G为user space，3G~4G为kernel space。

　　由于开启了分页机制，内核想要访问物理地址空间的话，必须先建立映射关系，然后通过虚拟地址来访问。为了能够访问所有的物理地址空间，就要将全部物理地址空间映射到1G的内核线性空间中，这显然不可能。于是，内核将0~896M的物理地址空间一对一映射到自己的线性地址空间中，这样它便可以随时访问ZONE_DMA和ZONE_NORMAL里的物理页面；此时内核剩下的128M线性地址空间不足以完全映射所有的ZONE_HIGHMEM，Linux采取了动态映射的方法，即按需的将ZONE_HIGHMEM里的物理页面映射到kernel space的最后128M线性地址空间里，使用完之后释放映射关系，以供其它物理页面映射。虽然这样存在效率的问题，但是内核毕竟可以正常的访问所有的物理地址空间了。

 

### buddyinfo的理解

cat /proc/buddyinfo 显示如下：

Node 0, zone    DMA    0    4    5    4    4    3 ...

Node 0, zone  Normal    1    0    0    1   101   8 ...

Node 0, zone  HighMem   2    0    0    1    1    0 ...

其中，Node表示在NUMA环境下的节点号，这里只有一个节点0；zone表示每一个节点下的区域，一般有DMA、Normal和HignMem三个区域；后面的列表示，伙伴系统中每一个order对应的空闲页面块。例如，对于zone DMA的第二列（从0开始算起），空闲页面数为5*2^4，可用内存为5*2^4*PAGE_SIZE。

 计算方法就是：

​          ` 当前列的数字*2^列数*PAGE_SIZE 其中列数是从0开始计算的，即第一列是 当前列的数字*2^0*PAGE_SIZE`

## 常见问题

### 1、用户空间（进程）是否有高端内存概念？

用户进程没有高端内存概念。只有在内核空间才存在高端内存。用户进程最多只可以访问3G物理内存，而内核进程可以访问所有物理内存。

### 2、64位内核中有高端内存吗？

目前现实中，64位Linux内核不存在高端内存，因为64位内核可以支持超过512GB内存。若机器安装的物理内存超过内核地址空间范围，就会存在高端内存。

### 3、用户进程能访问多少物理内存？内核代码能访问多少物理内存？

32位系统用户进程最大可以访问3GB，内核代码可以访问所有物理内存。

64位系统用户进程最大可以访问超过512GB，内核代码可以访问所有物理内存。

### 4、高端内存和物理地址、逻辑地址、线性地址的关系？

高端内存只和逻辑地址有关系，和逻辑地址、物理地址没有直接关系。

### 5、为什么不把所有的地址空间都分配给内核？

若把所有地址空间都给内存，那么用户进程怎么使用内存？怎么保证内核使用内存和用户进程不起冲突？